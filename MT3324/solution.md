# 解题思路与算法（优化版）

> 目标：在总花费不超过 `v` 的前提下，买 `m` 个甜品，使中位数甜度最大。

## 1. 二分答案
设我们猜一个中位数下界 `x`，问题变为：

- 能否选出 `m` 个甜品，
- 总价 `<= v`，
- 且选中的甜品里，甜度 `>= x` 的数量至少为 `need = (m+1)//2`（对应奇数 `m` 的中位数定义）。

可行则尝试更大 `x`，不可行则减小 `x`，因此可对甜度做二分。

---

## 2. 可行性检查 `check(x)` 如何做得快
将甜品按 `x` 分两组：

- `high`：甜度 `>= x`，价格数组 `high_costs`
- `low`：甜度 `< x`，价格数组 `low_costs`

要满足中位数至少为 `x`，必须先买 `need` 个 `high`（若 `len(high) < need`，直接失败）。

为了总价最小：

1. 先取 `high_costs` 中最便宜的 `need` 个。
2. 剩下还要买 `m-need` 个，从“`high` 的剩余部分 + `low` 全部”里继续取最便宜的。

把两组价格排序后，用双指针做一次“归并式取最小”即可，复杂度线性于 `m`。

---

## 3. 复杂度
设 `n` 为甜品数量。

- 二分次数：`O(log n)`（在去重后的甜度数组上二分）。
- 每次检查：分组 `O(n)`，排序 `O(n log n)`，归并取最小 `O(m)`。

总复杂度约 `O(n log n log n)`，相较原始代码中大量 `pop + min + index` 的平方级操作，性能提升明显，可通过 `1e5` 规模数据。

---

## 4. 参考实现
见同目录 `solition.py`。
