# 解题思路与算法

## 关键观察
对固定右端点 `i`，所有以 `i` 结尾的子数组的按位与结果只会出现少量不同值。因为按位与只会让二进制位从 1 变为 0，所以每次扩展子数组时结果只会“减少”，不同值数量最多约为 31 种（由数值范围决定）。

## 算法思路
1. 维护字典 `prev`，记录“以上一位置结尾的子数组”的按位与值及出现次数。
2. 处理当前元素 `x` 时，建立新字典 `cur`：
   - 子数组 `[i, i]` 贡献 `cur[x] = 1`；
   - 对 `prev` 中每个 `(val, cnt)`，计算 `val & x` 并累加到 `cur`。
3. 将 `cur` 中所有 `val * cnt` 加入答案。
4. 令 `prev = cur`，继续处理下一元素。

## 复杂度分析
- 时间复杂度：每个位置最多合并约 31 种值，总体约为 $O(n \log A)$。
- 空间复杂度：$O(\log A)$。

## 参考实现
请见同目录下 `solition.py`。
