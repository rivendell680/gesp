# GESP Python 五级题目：子数组按位与求和

## 题目描述
给出一个长度为 `n` 的数列 `a`。定义

\[
 p_{i,j} = a_i \; \text{AND} \; a_{i+1} \; \text{AND} \; \cdots \; \text{AND} \; a_j
\]

其中 `AND` 表示按位与运算。请计算：

\[
\sum_{i=1}^{n} \sum_{j=i}^{n} p_{i,j}
\]

也就是所有连续子数组按位与结果的总和。

## 输入格式
- 第一行一个整数 `n`，表示数列长度；
- 第二行 `n` 个整数，表示数列 `a`。

## 输出格式
- 一个整数，表示答案。

## 样例
**输入：**
```
5
5 8 4 5 6
```

**输出：**
```
40
```

## 数据范围
- \(1 \le n \le 100000\)
- \(0 \le a_i \le 10^9\)

---

## 题目拆解
1. **要计算的量**：所有连续子数组的按位与结果之和。
2. **子数组数量**：共有 \(\frac{n(n+1)}{2}\) 个子数组，不能直接枚举。
3. **关键性质**：对固定右端点 `i`，所有以 `i` 结尾的子数组的按位与值只会出现少量不同结果（最多约 31 种，因为按位与只会减少位）。
4. **核心思路**：
   - 维护“所有以当前位置结尾的子数组”的按位与值及其出现次数；
   - 每加入一个新元素 `a[i]`，将之前的按位与值与 `a[i]` 再做一次与运算并合并；
   - 把这些结果的“值 × 次数”累加到答案中。

---

## 算法思路
- 使用一个字典 `prev`，保存上一位置所有子数组的按位与结果及其出现次数。
- 新加入 `a[i]` 时：
  - 新字典 `cur` 初始包含 `{a[i]: 1}`（子数组 `[i, i]`）；
  - 对 `prev` 中每个 `(value, count)`，计算 `value & a[i]` 并累加次数；
- 把 `cur` 中所有 `value * count` 加入答案；
- 更新 `prev = cur`，继续下一位。

### 复杂度分析
- **时间复杂度**：每个位置的不同按位与值数量最多约 31 种，所以总体约 \(O(n \log A)\)。
- **空间复杂度**：\(O(\log A)\)。

---

## Python3 参考代码
请见同目录下 `solution.py`。
